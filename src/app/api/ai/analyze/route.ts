import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  try {
    const { entityId } = await request.json();

    if (!entityId) {
      return NextResponse.json(
        { error: 'entityId is required' },
        { status: 400 }
      );
    }

    // Check if this entity already exists in our database
    const existingEntity = await prisma.scaryEntity.findUnique({
      where: { googleKgId: entityId },
      include: {
        analysis: {
          include: {
            dimensionScores: {
              include: {
                dimension: true
              }
            }
          }
        }
      }
    });

    if (existingEntity && existingEntity.analysis) {
      // Return cached analysis
      const analysis = {
        whyScary: existingEntity.analysis.whyScary,
        dimensionScores: existingEntity.analysis.dimensionScores.map((score: any) => ({
          dimensionId: score.dimension.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
          score: score.score,
          reasoning: score.reasoning
        }))
      };

      // Calculate user ratings average
      const userRatings = await prisma.scaryRating.findMany({
        where: { entityId: existingEntity.id },
        include: { dimension: true }
      });

      let userRatingsData = undefined;
      if (userRatings.length > 0) {
        const totalScore = userRatings.reduce((sum, rating) => sum + rating.score, 0);
        const averageScore = totalScore / userRatings.length;
        const uniqueUsers = new Set(userRatings.map(rating => rating.userId)).size;
        
        userRatingsData = {
          averageScore: Math.round(averageScore * 10) / 10, // Round to 1 decimal
          totalRatings: uniqueUsers
        };
      }

      return NextResponse.json({
        entity: {
          id: existingEntity.googleKgId,
          dbId: existingEntity.id,
          slug: existingEntity.slug,
          name: existingEntity.name,
          description: existingEntity.description,
          types: [existingEntity.entityType],
          imageUrl: existingEntity.imageUrl,
          score: 1,
          // Include integration data if available
          // Movie data
          posterUrl: existingEntity.posterUrl,
          backdropUrl: existingEntity.backdropUrl,
          releaseDate: existingEntity.releaseDate,
          runtime: existingEntity.runtime,
          homepage: existingEntity.homepage,
          imdbId: existingEntity.imdbId,
          tmdbUrl: existingEntity.tmdbUrl,
          // Book data
          googleBooksId: existingEntity.googleBooksId,
          bookCoverUrl: existingEntity.bookCoverUrl,
          isbn10: existingEntity.isbn10,
          isbn13: existingEntity.isbn13,
          pageCount: existingEntity.pageCount,
          publishDate: existingEntity.publishDate,
          publishers: existingEntity.publishers,
          bookAuthors: existingEntity.bookAuthors,
          googleBooksUrl: existingEntity.googleBooksUrl,
          // Music data
          musicBrainzId: existingEntity.musicBrainzId,
          albumArtUrl: existingEntity.albumArtUrl,
          musicArtists: existingEntity.musicArtists,
          musicReleaseDate: existingEntity.musicReleaseDate,
          trackCount: existingEntity.trackCount,
          musicType: existingEntity.musicType,
          musicBrainzUrl: existingEntity.musicBrainzUrl,
          lastFmUrl: existingEntity.lastFmUrl,
          // Wikipedia data
          wikipediaPageId: existingEntity.wikipediaPageId,
          wikipediaExtract: existingEntity.wikipediaExtract,
          wikipediaImageUrl: existingEntity.wikipediaImageUrl,
          wikipediaCategories: existingEntity.wikipediaCategories,
          wikipediaUrl: existingEntity.wikipediaUrl,
        },
        analysis,
        userRatings: userRatingsData,
      });
    }

    // Entity not in database - check if it's being generated by another request
    // Check the generation queue or recent search activity
    return NextResponse.json(
      { 
        status: 'pending',
        message: 'Entity not yet in database. It may be generating in the background.',
        error: 'Entity not found. Please search for this entity first to generate its wiki page.' 
      },
      { status: 404 }
    );
  } catch (error) {
    console.error('AI analysis error:', error);
    return NextResponse.json(
      { error: 'Failed to generate scary analysis' },
      { status: 500 }
    );
  }
}